"use strict";(self.webpackChunkvuepress_starter=self.webpackChunkvuepress_starter||[]).push([[4087],{7131:(e,t,a)=>{a.r(t),a.d(t,{data:()=>p});const p={key:"v-42b87840",path:"/note/js/38.Event-object.html",title:"39. 事件对象",lang:"zh-CN",frontmatter:{title:"39. 事件对象",date:"2017-06-22T00:00:00.000Z",tags:["JS"]},excerpt:"",headers:[{level:2,title:"获取事件对象",slug:"获取事件对象",children:[]},{level:2,title:"事件对象的通用成员",slug:"事件对象的通用成员",children:[]}],filePathRelative:"note/js/38.Event-object.md",git:{updatedTime:1628577068e3,contributors:[{name:"n",email:"n@nannandeMacBook-Air.local",commits:1}]}}},6884:(e,t,a)=>{a.r(t),a.d(t,{default:()=>l});const p=(0,a(6252).uE)('<h1 id="事件对象" tabindex="-1"><a class="header-anchor" href="#事件对象" aria-hidden="true">#</a> 事件对象</h1><p>事件对象封装了事件的相关信息</p><h2 id="获取事件对象" tabindex="-1"><a class="header-anchor" href="#获取事件对象" aria-hidden="true">#</a> 获取事件对象</h2><ul><li>通过事件处理函数的参数获取</li><li>旧版本的 IE 浏览器，通过 window.event 获取</li></ul><h2 id="事件对象的通用成员" tabindex="-1"><a class="header-anchor" href="#事件对象的通用成员" aria-hidden="true">#</a> 事件对象的通用成员</h2><ul><li><p>target &amp; srcElement</p><p>事件目标（事件源）</p><p>事件委托：通过给祖先元素注册事件，在事件处理程序中，判断事件源进行不同的处理。</p><p>通常，事件委托用于动态生成元素的区域。</p></li><li><p>currentTarget</p><p>当前目标：获取绑定事件的元素，等效于 this</p></li><li><p>type</p><p>字符串，得到事件的类型。</p></li><li><p>preventDefault &amp; returnValue</p><p><code>preventDefault()</code> 方法</p><p>阻止浏览器默认行为。</p><p>DOM0 的方式：在事件处理程序中返回 false。</p><p>针对 a 元素，可以设置为功能性链接解决跳转问题</p></li><li><p><code>stopPropagation()</code> 方法</p><p>阻止事件冒泡</p></li><li><p>eventPhase</p><p>得到事件所处的阶段</p><p>1:事件捕获 2:事件目标 3:事件冒泡</p></li></ul><p>补充：</p><blockquote><p><code>tagName</code>：返回当前元素的标签名 语法 <code>element.tagName</code></p></blockquote>',8),l={render:function(e,t){return p}}}}]);